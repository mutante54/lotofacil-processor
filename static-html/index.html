<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <title>Concursos Lotofácil</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 2em;
    }

    table {
      border-collapse: collapse;
      width: 100%;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }

    th {
      background: #eee;
    }
  </style>
</head>

<body>
  <h1>Estatísticas (últimos 50 concursos)</h1>
  <table id="stats-table">
    <thead>
      <tr>
        <th style="background-color: mediumseagreen;">Dezenas que mais ocorrem</th>
        <th style="background-color: #acc5ab">Dez. Maior Sequência - Ocorrências <i>(min = 2)</i></th>
        <th style="background-color: #f2f28a">Dezenas mais ausentes</th>
        <th style="background-color: #e7e6a9">Dez. Maior Sequência - Ausente <i>(min = 2)</i></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <h1>Concursos Lotofácil</h1><span id="limits-display"></span>
  <br /><br />
  <div style="max-height: 400px; overflow-y: auto;">
    <table id="concursos-table">
      <thead>
        <tr>
          <th>ID</th>
          <th>Data</th>
          <th>Dezenas</th>
          <th>Oc. / Aus. / Amb.</th>
          <th>Padrão Altern.</th>
          <th>Dezenas Ausentes</th>
          <th>Dezenas Novas C. Anterior</th>
          <th>Dezenas Repetidas C. Anterior</th>
          <!-- Adicione mais colunas conforme necessário -->
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <!-- Modal for Mirror Games -->
  <div id="mirrorGamesModal"
    style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.5);z-index:9999;align-items:center;justify-content:center;">
    <div style="background:#fff;padding:2em;border-radius:8px;max-width:500px;margin:auto;position:relative;">
      <h2>Gerar Jogos Espelho</h2>
      <label>Quantidade de jogos:<br>
        <input type="number" id="mirrorGamesQtdJogos" min="1" value="5" style="width:80px;">
      </label><br><br>
      <label>Quantidade de dezenas por jogo:<br>
        <input type="number" id="mirrorGamesQtdDezenas" min="1" max="25" value="15" style="width:80px;">
      </label><br><br>
      <label>Dezenas a repetir em todos os jogos:<br>
        <div id="mirrorGamesDezenasRepeat" style="margin-top:5px;margin-bottom:10px;"></div>
      </label>
      <button id="mirrorGamesGenerateBtn">Gerar Jogos</button>
      <button id="mirrorGamesSugRepeatBtn">Sugerir Repetições</button>
      <button id="mirrorGamesCloseBtn" type="button" style="position:absolute;top:10px;right:10px;">&times;</button>
      <div id="mirrorGamesResults" style="margin-top:1em;"></div>
    </div>
  </div>
  <script>
    // Add event listener for modal close button (CSP safe)
    document.addEventListener('DOMContentLoaded', function () {
      var closeBtn = document.getElementById('mirrorGamesCloseBtn');
      if (closeBtn) {
        closeBtn.addEventListener('click', closeMirrorGamesModal);
      }
    });
    // Mirror Games Modal Logic
    let mirrorGamesSelectedDezenas = [];
    let mirrorGamesBaseDezenas = [];
    let mirrorGamesParams = {
      qtdJogos: 5,
      qtdDezenas: 15,
      dezenasRepeat: []
    };

    function openMirrorGamesModal(dezenas) {
      mirrorGamesBaseDezenas = dezenas;
      // Only reset dezenasRepeat if base dezenas changed
      if (JSON.stringify(mirrorGamesBaseDezenas) !== JSON.stringify(dezenas)) {
        mirrorGamesParams.dezenasRepeat = [];
      }
      document.getElementById('mirrorGamesQtdJogos').value = mirrorGamesParams.qtdJogos;
      document.getElementById('mirrorGamesQtdDezenas').value = mirrorGamesParams.qtdDezenas;
      renderMirrorGamesDezenasRepeat(dezenas);
      // generateMirrorGames();
      document.getElementById('mirrorGamesModal').style.display = 'flex';
    }

    function closeMirrorGamesModal() {
      document.getElementById('mirrorGamesResults').innerHTML = '';
      document.getElementById('mirrorGamesModal').style.display = 'none';
    }

    function renderMirrorGamesDezenasRepeat(dezenas) {
      const container = document.getElementById('mirrorGamesDezenasRepeat');
      const maisSorteadasSet = new Set((estatisticas.maisSorteadas || []).map(ms => ms.dezena));
      const maisAusentesSet = new Set((estatisticas.maisAusentes || []).map(ma => ma.dezena));
      container.innerHTML = dezenas.map(d => {
        let backColor = 'none';
        if (maisSorteadasSet.has(d) && maisAusentesSet.has(d)) {
          backColor = 'thistle';
        } else if (maisSorteadasSet.has(d)) {
          backColor = 'mediumseagreen';
        } else if (maisAusentesSet.has(d)) {
          backColor = '#f2f28a';
        }
        return `<label style='margin-right:8px;padding:2px 6px;border-radius:4px;background:${backColor};'><input type='checkbox' value='${d}' class='mirror-dezena-checkbox' style='margin-right:6px;'>${d}</label>`
      }).join(' ');
      // Add event listeners CSP-safe
      container.querySelectorAll('.mirror-dezena-checkbox').forEach(cb => {
        cb.addEventListener('change', function () {
          const val = Number(this.value);
          if (this.checked) {
            if (!mirrorGamesParams.dezenasRepeat.includes(val)) mirrorGamesParams.dezenasRepeat.push(val);
          } else {
            mirrorGamesParams.dezenasRepeat = mirrorGamesParams.dezenasRepeat.filter(d => d !== val);
          }
        });
      });
    }

    function onMirrorGamesDezenaRepeatChange(checkbox) {
      const val = Number(checkbox.value);
      if (checkbox.checked) {
        if (!mirrorGamesParams.dezenasRepeat.includes(val)) mirrorGamesParams.dezenasRepeat.push(val);
      } else {
        mirrorGamesParams.dezenasRepeat = mirrorGamesParams.dezenasRepeat.filter(d => d !== val);
      }
    }

    document.getElementById('mirrorGamesGenerateBtn').onclick = function () {
      mirrorGamesParams.qtdJogos = Number(document.getElementById('mirrorGamesQtdJogos').value);
      mirrorGamesParams.qtdDezenas = Number(document.getElementById('mirrorGamesQtdDezenas').value);
      generateMirrorGames();
    };    

    // Sugere dezenas para repetir segundo prioridades definidas nas estatísticas
    document.getElementById('mirrorGamesSugRepeatBtn').addEventListener('click', function () {
      sugerirDezenasParaRepeticao();
    });

    function sugerirDezenasParaRepeticao() {
      // garante que estatisticas esteja disponível
      const maisSorteadas = (estatisticas.maisSorteadas || []).map(i => i.dezena);
      const maisAusentes = (estatisticas.maisAusentes || []).map(i => i.dezena);
      const maioresSeq = (estatisticas.maioresSequencias || []).map(i => ({ dezena: i.dezena, seq: i.sequencia || i.sequencia || 0 }));
      const maioresSeqAusente = (estatisticas.maioresSequenciasAusente || []).map(i => ({ dezena: i.dezena, seq: i.sequencia || 0 }));

      const setMaisS = new Set(maisSorteadas);
      const setMaisA = new Set(maisAusentes);

      // a) presentes em ambas
      const prioridadeA = Array.from(setMaisS).filter(d => setMaisA.has(d));

      // b) presentes em uma das duas (exclui já incluídas em a)
      const union = Array.from(new Set([...maisSorteadas, ...maisAusentes]));
      const prioridadeB = union.filter(d => !prioridadeA.includes(d));

      // c) critérios de maioresSequencias vs maioresSequenciasAusente
      const mapSeq = new Map(maioresSeq.map(i => [i.dezena, Number(i.seq) || 0]));
      const mapSeqAus = new Map(maioresSeqAusente.map(i => [i.dezena, Number(i.seq) || 0]));
      const maxSeqAus = maioresSeqAusente.length > 0 ? Math.max(...maioresSeqAusente.map(i => Number(i.sequencia || 0))) : 0;

      const prioridadeC = [];
      for (const [dezena, seq] of mapSeq.entries()) {
        const seqAus = mapSeqAus.get(dezena) || 0;
        if (seq > seqAus && seq > maxSeqAus) {
          prioridadeC.push(Number(dezena));
        }
      }

      // Combina as prioridades na ordem solicitada, removendo duplicatas
      const combinado = [];
      prioridadeA.forEach(d => { if (!combinado.includes(Number(d))) combinado.push(Number(d)); });
      prioridadeB.forEach(d => { if (!combinado.includes(Number(d))) combinado.push(Number(d)); });
      prioridadeC.forEach(d => { if (!combinado.includes(Number(d))) combinado.push(Number(d)); });

      // Atualiza mirrorGamesParams.dezenasRepeat e checkboxes no DOM
      mirrorGamesParams.dezenasRepeat = combinado;

      const container = document.getElementById('mirrorGamesDezenasRepeat');
      if (container) {
        container.querySelectorAll('.mirror-dezena-checkbox').forEach(cb => {
          const val = Number(cb.value);
          cb.checked = mirrorGamesParams.dezenasRepeat.includes(val);
        });
      }

      // Atualiza resultados
      // generateMirrorGames();
    }

    function generateMirrorGames() {
      const {
        qtdJogos,
        qtdDezenas,
        dezenasRepeat
      } = mirrorGamesParams;
      const allDezenas = Array.from({
        length: 25
      }, (_, i) => i + 1);
      let jogos = [];
      for (let i = 0; i < qtdJogos; i++) {
        let jogo = [...dezenasRepeat];
        let restantes = allDezenas.filter(d => !jogo.includes(d));
        while (jogo.length < qtdDezenas && restantes.length > 0) {
          const idx = Math.floor(Math.random() * restantes.length);
          jogo.push(restantes[idx]);
          restantes.splice(idx, 1);
        }
        jogo = Array.from(new Set(jogo)).slice(0, qtdDezenas).sort((a, b) => a - b);
        jogos.push(jogo);
      }
      // Display results
      const html = jogos.map((jogo, idx) =>
        `<div style='margin-bottom:8px;'><b>Jogo ${idx+1}:</b> ` +
        jogo.map(d => {
          const isRepeat = dezenasRepeat.includes(d);
          return `<span style="background:${isRepeat ? '#d1e7dd' : 'none'};padding:2px 6px;border-radius:4px;">${d}</span>`;
        }).join(', ') + '</div>'
      ).join('');
      document.getElementById('mirrorGamesResults').innerHTML = html;
    }

    function obterPadraoAlternanciaFormatado(dezenas) {
      let countPadraoAlternancia2 = 0;
      let countPadraoAlternancia3 = 0;
      let countPadraoAlternancia4 = 0;
      let padrao = '';
      for (let i = 0; i < dezenas.length; i++) {
        const current = dezenas[i];
        // pega a próxima dezena ou 26 se for a última (25 é o maior número possível + 1 para base de calculo)
        const next = i < (dezenas.length - 1) ? dezenas[i + 1] : 26;
        if (current === undefined || next === undefined) {
          continue;
        }
        let diff = next - current;
        if (diff == 3) {
          countPadraoAlternancia2++;
        } else if (diff == 4) {
          countPadraoAlternancia3++;
        } else if (diff == 5) {
          countPadraoAlternancia4++;
        }
      }
      if (countPadraoAlternancia2 > 0) {
        padrao += `<b>2</b> [${countPadraoAlternancia2}]`;
      }
      if (countPadraoAlternancia3 > 0) {
        if (padrao.length > 0) {
          padrao += ', ';
        }
        padrao += `<b>3</b> [${countPadraoAlternancia3}]`;
      }
      if (countPadraoAlternancia4 > 0) {
        if (padrao.length > 0) {
          padrao += ', ';
        }
        padrao += `<b>4</b> [${countPadraoAlternancia4}]`;
      }

      return padrao;
    }

    const limitDataAnalysis = 50; // Alterar aqui o limite de concursos exibidos/ dados estatísticas
    const limitConcursosDisplay = 50; // Alterar aqui o limite de concursos exibidos na tabela    
    const ultimoConcursoDezenas = []; // Array para armazenar as dezenas do último concurso
    const ultimoConcursoDezenasAusentes = []; // Array para armazenar as dezenas ausentes do último concursos
    var estatisticas = {};
    const TipoParametroDezenasConsolidado = Object.freeze({
      OCORRENCIAS: 'MaisOcorrem',
      AUSENCIAS: 'Ausentes',
      AMBAS: 'MaisOcorremEAusentes',
      REPETIDAS_CA: 'RepetidasCA',
    });
    const dadosConsolidadosDezenas = [];

    limitsDisplay = document.getElementById('limits-display');
    limitsDisplay.innerHTML =
      `<i>(Exibindo os últimos <u>${limitConcursosDisplay}</u> concursos de um total de <u>${limitDataAnalysis}</u> analisados</i>)`;

    fetch('/concursos?limit=' + limitDataAnalysis)
      .then(res => res.json())
      .then(dataConcursos => {
        const concursos = dataConcursos.data;
        let somaOcAusAmbTotal = 0;
        let somaCountDezenasAusentes = 0;
        let somaCountDezenasNovasCA = 0;
        let somaCountDezenasRepetidasCA = 0;
        let somaCountMaisOcorremTotal = 0;
        let somaCountMaisAtrasadasTotal = 0;
        let somaCountAmbasTotal = 0;
        let firstConcurso = concursos[0];
        let concursoIndex = 0;
        const tbody = document.querySelector('#concursos-table tbody');
        let arrayCountsMaisOcorrem = [];
        let arrayCountsMaisAtrasadas = [];
        let arrayCountsAmbas = [];
        let arrayCountsRepetidasCA = [];
        let arrayCountsNovasCA = [];
        let mapModasCombinada = new Map();
        fetch('/stats?limit=' + limitDataAnalysis)
          .then(res => res.json())
          .then(data => {
            estatisticas = data.data.estatisticas;
            concursos.forEach(concurso => {
              concursoIndex++;
              // Array de dezenas que devem ser destacadas
              const destaqueMaisOcorrem = concurso.estaticPreConcMaisOcorrencias || [];
              const destaqueMaisAtrasadas = concurso.estaticPreConcMaisAtrasadas || [];
              let countMaisOcorrem = 0;
              let countMaisAtrasadas = 0;
              let countAmbas = 0;

              somaCountDezenasAusentes += concurso.dezenasAusentes.length;
              somaCountDezenasNovasCA += concurso.dezenasNovasConcursoAnterior.length;
              somaCountDezenasRepetidasCA += concurso.dezenasRepetidasConcursoAnterior.length;

              arrayCountsNovasCA.push(concurso.dezenasNovasConcursoAnterior.length);
              arrayCountsRepetidasCA.push(concurso.dezenasRepetidasConcursoAnterior.length);

              if (concursoIndex === 1) {
                // Armazena as dezenas do primeiro concurso (mais recente)
                ultimoConcursoDezenas.push(...concurso.dezenas);
                ultimoConcursoDezenasAusentes.push(...concurso.dezenasAusentes);
              }

              // Renderiza cada dezena com cor de fundo se estiver em destaque
              const dezenasHtml = concurso.dezenas.map(dezena => {
                let backColor = 'none';
                const isDestaqueMaisOcorrem = destaqueMaisOcorrem.includes(dezena);
                const isDestaqueMaisAtrasadas = destaqueMaisAtrasadas.includes(dezena);
                if (isDestaqueMaisOcorrem && isDestaqueMaisAtrasadas) {
                  backColor = 'thistle'; // Cor para ambas as condições
                  countAmbas++;
                } else if (isDestaqueMaisOcorrem) {
                  backColor = 'mediumseagreen'; // Cor para mais ocorrem
                  countMaisOcorrem++;
                } else if (isDestaqueMaisAtrasadas) {
                  backColor = '#f2f28a'; // Cor para mais atrasadas
                  countMaisAtrasadas++;
                }
                return `<span style="background:${backColor};padding:2px 6px;border-radius:4px;">${dezena}</span>`;
              }).join(', ');
              let somaOcAusAmb = (countMaisOcorrem + countMaisAtrasadas + countAmbas);
              somaOcAusAmbTotal += somaOcAusAmb;
              somaCountMaisAtrasadasTotal += countMaisAtrasadas;
              somaCountMaisOcorremTotal += countMaisOcorrem;
              somaCountAmbasTotal += countAmbas;

              arrayCountsAmbas.push(countAmbas);
              arrayCountsMaisAtrasadas.push(countMaisAtrasadas);
              arrayCountsMaisOcorrem.push(countMaisOcorrem);

              modaCombinadaKey = countMaisOcorrem + ' / ' + countMaisAtrasadas + " / " + countAmbas;
              mapModasCombinada.set(modaCombinadaKey, (mapModasCombinada.get(modaCombinadaKey) || 0) + 1);

              let dezenasAusentesHtml = null;
              if (concurso.numero === firstConcurso.numero) {
                // Renderiza cada dezena ausente com cor de fundo se estiver em destaque
                dezenasAusentesHtml = concurso.dezenasAusentes.map(dezenaAusente => {
                  let backColor = 'none';
                  const isDestaqueMaisOcorrem = estatisticas.maisSorteadas.filter(item => item.dezena ===
                    dezenaAusente).length > 0;
                  const isDestaqueMaisAtrasadas = estatisticas.maisAusentes.filter(item => item.dezena ===
                    dezenaAusente).length > 0;
                  if (isDestaqueMaisOcorrem && isDestaqueMaisAtrasadas) {
                    backColor = 'thistle'; // Cor para ambas as condições
                  } else if (isDestaqueMaisOcorrem) {
                    backColor = 'mediumseagreen'; // Cor para mais ocorrem
                  } else if (isDestaqueMaisAtrasadas) {
                    backColor = '#f2f28a'; // Cor para mais atrasadas
                  }
                  return `<span style="background:${backColor};padding:2px 6px;border-radius:4px;">${dezenaAusente}</span>`;
                }).join(', ');
              }
              if (concursoIndex <= limitConcursosDisplay) {
                const tr = document.createElement('tr');
                tr.innerHTML = `            
            <td>${concurso.numero}</td>
            <td>${concurso.data.substring(0,10)}</td>             
            <td>${dezenasHtml}</td>
            <td>${countMaisOcorrem} / ${countMaisAtrasadas} / ${countAmbas} - <b>(${somaOcAusAmb})</b></td>
            <td>${concurso.padraoAlternancia ? Object.entries(concurso.padraoAlternancia).map(([key, value]) => `<b>${key}</b> [${value}]`).join(', ') : ''}</td>
            <td>${dezenasAusentesHtml ? dezenasAusentesHtml : concurso.dezenasAusentes.join(', ')}</td>
            <td>${concurso.dezenasNovasConcursoAnterior.join(', ')} - <b>(${concurso.dezenasNovasConcursoAnterior.length})</b></td>
            <td>${concurso.dezenasRepetidasConcursoAnterior.join(', ')} - <b>(${concurso.dezenasRepetidasConcursoAnterior.length})</b></td>
            `;
                tbody.appendChild(tr);
              }

            });
            let mediaOcAusAmb = Number((somaOcAusAmbTotal / concursos.length).toFixed(0));
            let mediaMaisOcorrem = Number((somaCountMaisOcorremTotal / concursos.length).toFixed(0));
            let mediaMaisAtrasadas = Number((somaCountMaisAtrasadasTotal / concursos.length).toFixed(0));
            let mediaAmbas = Number((somaCountAmbasTotal / concursos.length).toFixed(0));
            let mediaAmbasFixed2 = Number((somaCountAmbasTotal / concursos.length).toFixed(2));
            let mediaDezenasAusentes = Number((somaCountDezenasAusentes / concursos.length).toFixed(0));
            let mediaDezenasNovasCA = Number((somaCountDezenasNovasCA / concursos.length).toFixed(0));
            let mediaDezenasRepetidasCA = Number((somaCountDezenasRepetidasCA / concursos.length).toFixed(0));

            /**
             * Calcula a mediana de um array de números
             * @param {number[]} dados - Array de números para calcular a mediana
             * @returns {number|string} - A mediana ou uma mensagem de erro se o array estiver vazio
             */
            function calcularMediana(dados) {
              const n = dados.length;
              const dadosOrdenados = [...dados].sort((a, b) => a - b); // Cria uma cópia e ordena

              if (n === 0) {
                return "Não é possível calcular a mediana de um conjunto vazio.";
              }

              if (n % 2 !== 0) {
                // Número ímpar de elementos
                const indiceMeio = Math.floor(n / 2);
                return dadosOrdenados[indiceMeio];
              } else {
                // Número par de elementos
                const indice1 = n / 2 - 1;
                const indice2 = n / 2;
                return (dadosOrdenados[indice1] + dadosOrdenados[indice2]) / 2;
              }
            }

            /**
             * Encontra a moda (valor mais frequente) em um array de números
             * @param {number[]} numeros - Array de números para encontrar a moda
             * @returns {number|null} - A moda ou null se o array estiver vazio
             */
            function calcularModa(numeros) {
              // Cria um objeto para armazenar a frequência de cada número
              const frequencia = {};
              let moda = null;
              let maiorFrequencia = 0;

              // Itera sobre o array para contar a frequência de cada número
              for (const numero of numeros) {
                frequencia[numero] = (frequencia[numero] || 0) + 1;
              }

              // Itera sobre o objeto de frequência para encontrar o número com a maior frequência
              for (const numero in frequencia) {
                if (frequencia[numero] > maiorFrequencia) {
                  maiorFrequencia = frequencia[numero];
                  moda = Number(numero); // Converte para número, pois as chaves do objeto são strings
                }
              }

              return moda;
            }

            const trMedia = document.createElement('tr');
            trMedia.innerHTML = `
            <td></td>
            <td></td>
            <td style='background-color:#eee; text-align:center'><b>Médias:</b></td>
            <td style='text-align:center'><b>${mediaMaisOcorrem}</b> / <b>${mediaMaisAtrasadas}</b> / <b>${mediaAmbas}</b> - <b>(${mediaOcAusAmb})</b></td>
            <td></td>
            <td style='text-align:center'><b>${mediaDezenasAusentes}</b></td>
            <td style='text-align:center'><b>${mediaDezenasNovasCA}</b></td>
            <td style='text-align:center'><b>${mediaDezenasRepetidasCA}</b></td>
          `;
            tbody.appendChild(trMedia);

            const minMaisOcorrem = Math.min(...arrayCountsMaisOcorrem);
            const maxMaisOcorrem = Math.max(...arrayCountsMaisOcorrem);
            const minMaisAtrasadas = Math.min(...arrayCountsMaisAtrasadas);
            const maxMaisAtrasadas = Math.max(...arrayCountsMaisAtrasadas);
            const minAmbas = Math.min(...arrayCountsAmbas);
            const maxAmbas = Math.max(...arrayCountsAmbas);
            const minNovasCA = Math.min(...arrayCountsNovasCA);
            const maxNovasCA = Math.max(...arrayCountsNovasCA);
            const minRepetidasCA = Math.min(...arrayCountsRepetidasCA);
            const maxRepetidasCA = Math.max(...arrayCountsRepetidasCA);

            const trMin = document.createElement('tr');
            trMin.innerHTML = `
            <td></td>
            <td></td>
            <td style='background-color:#eee; text-align:center'><b>Mínimas:</b></td>
            <td style='text-align:center'><b>${minMaisOcorrem}</b> / <b>${minMaisAtrasadas}</b> / <b>${minAmbas}</b></td>
            <td style='text-align:center'></td>
            <td style='text-align:center'></td>
            <td style='text-align:center'><b>${minNovasCA}</b></td>
            <td style='text-align:center'><b>${minRepetidasCA}</b></td>
          `;
            tbody.appendChild(trMin);

            const trMax = document.createElement('tr');
            trMax.innerHTML = `
            <td></td>
            <td></td>
            <td style='background-color:#eee; text-align:center'><b>Máximas:</b></td>
            <td style='text-align:center'><b>${maxMaisOcorrem}</b> / <b>${maxMaisAtrasadas}</b> / <b>${maxAmbas}</b></td>
            <td style='text-align:center'></td>
            <td style='text-align:center'></td>
            <td style='text-align:center'><b>${maxNovasCA}</b></td>
            <td style='text-align:center'><b>${maxRepetidasCA}</b></td>
          `;
            tbody.appendChild(trMax);

            const medianaMaisOcorrem = calcularMediana(arrayCountsMaisOcorrem);
            const medianaMaisAtrasadas = calcularMediana(arrayCountsMaisAtrasadas);
            const medianaAmbas = calcularMediana(arrayCountsAmbas);
            const medianaNovasCA = calcularMediana(arrayCountsNovasCA);
            const medianaRepetidasCA = calcularMediana(arrayCountsRepetidasCA);

            const trMediana = document.createElement('tr');
            trMediana.innerHTML = `
            <td></td>
            <td></td>
            <td style='background-color:#eee; text-align:center'><b>Medianas:</b></td>
            <td style='text-align:center'><b>${medianaMaisOcorrem}</b> / <b>${medianaMaisAtrasadas}</b> / <b>${medianaAmbas}</b></td>
            <td style='text-align:center'></td>
            <td style='text-align:center'></td>
            <td style='text-align:center'><b>${medianaNovasCA}</b></td>
            <td style='text-align:center'><b>${medianaRepetidasCA}</b></td>
          `;
            tbody.appendChild(trMediana);

            const modaMaisOcorrem = calcularModa(arrayCountsMaisOcorrem);
            const modaMaisAtrasadas = calcularModa(arrayCountsMaisAtrasadas);
            const modaAmbas = calcularModa(arrayCountsAmbas);
            const modaNovasCA = calcularModa(arrayCountsNovasCA);
            const modaRepetidasCA = calcularModa(arrayCountsRepetidasCA);


            const trModa = document.createElement('tr');
            trModa.innerHTML = `
            <td></td>
            <td></td>
            <td style='background-color:#eee; text-align:center'><b>Modas:</b></td>
            <td style='text-align:center'><b>${modaMaisOcorrem}</b> / <b>${modaMaisAtrasadas}</b> / <b>${modaAmbas}</b></td>
            <td style='text-align:center'></td>
            <td style='text-align:center'></td>
            <td style='text-align:center'><b>${modaNovasCA}</b></td>
            <td style='text-align:center'><b>${modaRepetidasCA}</b></td>
          `;
            tbody.appendChild(trModa);

            const modasCombinadasMaisOcorreOrdenadasDesc = Array.from(mapModasCombinada.entries()).sort((a, b) => b[
              1] - a[1]);
            const trModaCombinada = document.createElement('tr');
            trModaCombinada.innerHTML = `
            <td></td>
            <td></td>
            <td style='background-color:#eee; text-align:center'><b>Moda Combinada:</b></td>
            <td style='text-align:center'><b>${modasCombinadasMaisOcorreOrdenadasDesc[0][0]} - (${modasCombinadasMaisOcorreOrdenadasDesc[0][1]})<br></b>
              <b>${modasCombinadasMaisOcorreOrdenadasDesc[1][0]} - (${modasCombinadasMaisOcorreOrdenadasDesc[1][1]})<br></b>
              <b>${modasCombinadasMaisOcorreOrdenadasDesc[2][0]} - (${modasCombinadasMaisOcorreOrdenadasDesc[2][1]})</b></td>
            <td style='text-align:center'></td>
            <td style='text-align:center'></td>
            <td style='text-align:center'></td>
          `;
            tbody.appendChild(trModaCombinada);

            // Estatísticas gerais
            const tbodyEst = document.querySelector('#stats-table tbody');
            const trEst = document.createElement('tr');
            trEst.innerHTML = `
        <td>${estatisticas.maisSorteadas.map(item => '<b>' + item.dezena + ' </b> (' + item.ocorrencias + ')').join(', ')}</td>
        <td>${estatisticas.maioresSequencias.map(item => '<b>' + item.dezena + ' </b> (' + item.sequencia + ')').join(', ')}</td> 
        <td>${estatisticas.maisAusentes.map(item => '<b>' + item.dezena + ' </b> (' + item.concursosSemSair + ')').join(', ')}</td>
        <td>${estatisticas.maioresSequenciasAusente.map(item => '<b>' + item.dezena + ' </b> (' + item.sequencia + ')').join(', ')}</td> 
        `;
            tbodyEst.appendChild(trEst);

            dadosConsolidadosDezenas.push({
              tipoParametro: TipoParametroDezenasConsolidado.OCORRENCIAS,
              media: mediaMaisOcorrem,
              mediana: medianaMaisOcorrem,
              moda: modaMaisOcorrem,
              min: minMaisOcorrem,
              max: maxMaisOcorrem
            });
            dadosConsolidadosDezenas.push({
              tipoParametro: TipoParametroDezenasConsolidado.AUSENCIAS,
              media: mediaMaisAtrasadas,
              mediana: medianaMaisAtrasadas,
              moda: modaMaisAtrasadas,
              min: minMaisAtrasadas,
              max: maxMaisAtrasadas
            });
            dadosConsolidadosDezenas.push({
              tipoParametro: TipoParametroDezenasConsolidado.AMBAS,
              media: mediaAmbas == 0 && mediaAmbasFixed2 > 0 ? 1 : mediaAmbas,
              mediana: medianaAmbas,
              moda: modaAmbas,
              min: minAmbas,
              max: maxAmbas
            });
            dadosConsolidadosDezenas.push({
              tipoParametro: TipoParametroDezenasConsolidado.REPETIDAS_CA,
              media: mediaDezenasRepetidasCA,
              mediana: medianaRepetidasCA,
              moda: modaRepetidasCA,
              min: minRepetidasCA,
              max: maxRepetidasCA
            });

            /**
             * Função utilitária para sortear dezenas aleatórias de um array, sem repetir
             */
            function sortearDezenas(array, qtd, dezenasJaEscolhidas = []) {
              const disponiveis = array.filter(d => !dezenasJaEscolhidas.includes(d));
              const resultado = [];
              while (resultado.length < qtd && disponiveis.length > 0) {
                const idx = Math.floor(Math.random() * disponiveis.length);
                resultado.push(disponiveis[idx]);
                disponiveis.splice(idx, 1);
              }
              return resultado;
            }

            /**
             * Gera um concurso de acordo com os critérios estatísticos
             */
            function gerarConcurso(qtdDezenas, criterios, estatisticas, ultimoConcursoDezenas) {
              let dezenas = [];
              let usadas = [];
              let qtdMaisOcorremUsadas = 0;
              const maisSorteadas = new Set((estatisticas.maisSorteadas || []).map(ms => ms.dezena));
              const maisAusentes = new Set((estatisticas.maisAusentes || []).map(ma => ma.dezena));

              // Repetidas CA
              if (criterios.repetidasCA > 0 && ultimoConcursoDezenas.length > 0) {
                // candidatos preferenciais: do último concurso, entre as dezenas que mais ocorrem, obedecendo o limite do critéro MaisOcorrem
                const candidatosFiltrados = ultimoConcursoDezenas.filter(d => maisSorteadas.has(d) && !usadas
                  .includes(d)).slice(0, criterios.maisOcorrem);
                let rep = sortearDezenas(candidatosFiltrados, candidatosFiltrados.length, usadas);
                qtdMaisOcorremUsadas += rep.length;

                if (rep.length < criterios.repetidasCA) {
                  // se não atingiu o número desejado, completa com outras dezenas do último concurso (que não sejam as mais ocorrem)
                  const restantes = ultimoConcursoDezenas.filter(d => !maisSorteadas.has(d));
                  const adicionais = sortearDezenas(restantes, (criterios.repetidasCA - rep.length), rep);
                  rep = rep.concat(adicionais);
                }

                dezenas = dezenas.concat(rep);
                usadas = usadas.concat(rep);
              }

              // Mais sorteadas (desde que o critério Repetidas CA não tenha usado todas - 
              // e desde que nao estejam entre as mais ausentes - evita conflito com critério Ambas)
              if (criterios.maisOcorrem > 0 && qtdMaisOcorremUsadas < criterios.maisOcorrem) {
                const maisSorteadasFiltrados = estatisticas.maisSorteadas.filter(d => !ultimoConcursoDezenas
                  .includes(d.dezena) && !maisAusentes.has(d.dezena) && !usadas.includes(d.dezena)).map(d => d
                  .dezena);
                const maisOcorremEscolhidas = sortearDezenas(maisSorteadasFiltrados, (criterios.maisOcorrem -
                  qtdMaisOcorremUsadas), usadas);
                dezenas = dezenas.concat(maisOcorremEscolhidas);
                usadas = usadas.concat(maisOcorremEscolhidas);
              }

              // Mais atrasadas (não podem estar entre as mais sorteadas - evita conflito com critério Ambas)
              if (criterios.maisAtrasadas > 0) {
                const maisAtrasadasFiltradas = estatisticas.maisAusentes.filter(ma => !maisSorteadas.has(ma.dezena))
                  .map(ma => ma.dezena);
                const atrasadasEscolhidas = sortearDezenas(maisAtrasadasFiltradas, criterios.maisAtrasadas, usadas);
                dezenas = dezenas.concat(atrasadasEscolhidas);
                usadas = usadas.concat(atrasadasEscolhidas);
              }

              // Ambas (mais sorteadas e mais ausentes)
              if (criterios.ambas > 0) {
                const ambas = estatisticas.maisSorteadas
                  .filter(ms => estatisticas.maisAusentes.some(ma => ma.dezena === ms.dezena))
                  .map(ms => ms.dezena);
                const ambasEscolhidas = sortearDezenas(ambas, criterios.ambas, usadas);
                dezenas = dezenas.concat(ambasEscolhidas);
                usadas = usadas.concat(ambasEscolhidas);
              }             

              // Completa com dezenas aleatórias se faltar (double-check para garantir que dezenas do último concurso não sejam usadas aqui)
              // além disso, evita usar as dezenas mais ausentes (top 5). Neste caso, se faltar, sorteia entre as demais 5 dezenas aleatórias restantes.
              if (dezenas.length < qtdDezenas) {
                const todas = Array.from({
                  length: 25
                }, (_, i) => i + 1);
                const todasFiltradas = todas.filter(d => !ultimoConcursoDezenas.includes(d) && !maisAusentes.has(d));
                const restantes = sortearDezenas(todasFiltradas, qtdDezenas - dezenas.length, usadas);
                dezenas = dezenas.concat(restantes);
              }

              // Garante que não há repetidas
              dezenas = Array.from(new Set(dezenas)).slice(0, qtdDezenas);

              return dezenas.sort((a, b) => a - b);
            }

            /**
             * Embaralha um array usando o algoritmo de Fisher-Yates
             * @param {Array} array - O array a ser embaralhado
             * @returns {Array} - O array embaralhado
             */
            function shuffle(array) {
              let currentIndex = array.length,
                randomIndex;

              // Enquanto houver elementos para embaralhar.
              while (currentIndex !== 0) {
                // Pega um elemento restante.
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                // E troca com o elemento atual.
                [array[currentIndex], array[randomIndex]] = [
                  array[randomIndex], array[currentIndex]
                ];
              }

              return array;
            }

            /**
             * Gera e exibe a tabela de concursos simulados
             */
            function gerarTabelaConcursosSimulados(estatisticas, dadosConsolidadosDezenas, ultimoConcursoDezenas,
              ultimoConcursoDezenasAusentes) {
              const criteriosList = [{
                  nome: 'Media',
                  ...dadosConsolidadosDezenas.find(d => d.tipoParametro === TipoParametroDezenasConsolidado
                    .OCORRENCIAS),
                  maisOcorrem: Number(dadosConsolidadosDezenas.find(d => d.tipoParametro ===
                    TipoParametroDezenasConsolidado.OCORRENCIAS).media)
                },
                {
                  nome: 'Mediana',
                  ...dadosConsolidadosDezenas.find(d => d.tipoParametro === TipoParametroDezenasConsolidado
                    .OCORRENCIAS),
                  maisOcorrem: Number(dadosConsolidadosDezenas.find(d => d.tipoParametro ===
                    TipoParametroDezenasConsolidado.OCORRENCIAS).mediana)
                },
                {
                  nome: 'Moda',
                  ...dadosConsolidadosDezenas.find(d => d.tipoParametro === TipoParametroDezenasConsolidado
                    .OCORRENCIAS),
                  maisOcorrem: Number(dadosConsolidadosDezenas.find(d => d.tipoParametro ===
                    TipoParametroDezenasConsolidado.OCORRENCIAS).moda)
                },
              ];

              // Ajuste para os demais critérios
              criteriosList.forEach(criterio => {
                criterio.maisAtrasadas = Number(dadosConsolidadosDezenas.find(d => d.tipoParametro ===
                  TipoParametroDezenasConsolidado.AUSENCIAS)[criterio.nome.toLowerCase()]);
                criterio.ambas = Number(dadosConsolidadosDezenas.find(d => d.tipoParametro ===
                  TipoParametroDezenasConsolidado.AMBAS)[criterio.nome.toLowerCase()]);
                criterio.repetidasCA = Number(dadosConsolidadosDezenas.find(d => d.tipoParametro ===
                  TipoParametroDezenasConsolidado.REPETIDAS_CA)[criterio.nome.toLowerCase()]);
                criterio.novasCA = 0; // Ajuste se quiser usar dezenas novas do último concurso
              });

              const qtdDezenas = 15; // ou outro valor conforme parâmetro
              const tabela = document.createElement('table');
              tabela.style.marginTop = '2em';
              tabela.innerHTML = `
              <thead>
                <tr>
                  <th>Critério</th>
                  <th>Dezenas Geradas</th>
                  <th>Padrão Altern.</th>
                  <th>Ação</th>
                </tr>
              </thead>
              <tbody></tbody>
            `;
              const tbody = tabela.querySelector('tbody');

              criteriosList.forEach(criterio => {
                const dezenas = gerarConcurso(qtdDezenas, criterio, estatisticas, shuffle(ultimoConcursoDezenas));
                const dezenasHtml = dezenas.map(d => {
                  const isMaisSorteada = estatisticas.maisSorteadas.map(ms => ms.dezena).includes(d);
                  const isMaisAusente = estatisticas.maisAusentes.map(ma => ma.dezena).includes(d);
                  const isRepetidaCA = ultimoConcursoDezenas.includes(d);
                  let backColor = 'none';
                  if (isMaisSorteada && isMaisAusente) {
                    backColor = 'thistle';
                  } else if (isMaisSorteada) {
                    backColor = 'mediumseagreen';
                  } else if (isMaisAusente) {
                    backColor = '#f2f28a';
                  }
                  const borderStyle = isRepetidaCA ? 'border:3px solid #888;' : '';
                  return `<span style="background:${backColor};padding:2px 6px;border-radius:4px;${borderStyle}">${d}</span>`;
                }).join(', ');
                const tr = document.createElement('tr');
                tr.innerHTML =
                  `<td>${criterio.nome}</td><td>${dezenasHtml}</td><td>${obterPadraoAlternanciaFormatado(dezenas)}</td><td><button class="btn-mirror-games" data-dezenas="${dezenas.join(',')}">Gerar Jogos Espelho</button></td>`;
                tbody.appendChild(tr);
                // Add event listeners to the new buttons (after all rows are appended)
                setTimeout(() => {
                  document.querySelectorAll('.btn-mirror-games').forEach(btn => {
                    btn.addEventListener('click', function () {
                      const dezenas = this.getAttribute('data-dezenas').split(',').map(Number);
                      openMirrorGamesModal(dezenas);
                    });
                  });
                }, 0);
              });

              document.body.appendChild(tabela);
            }

            // Chame a função após o carregamento dos dados consolidados e estatísticas
            // Exemplo (coloque após o processamento dos dados no seu script):
            gerarTabelaConcursosSimulados(estatisticas, dadosConsolidadosDezenas, ultimoConcursoDezenas,
              ultimoConcursoDezenasAusentes);

          });
      });
  </script>
</body>

</html>